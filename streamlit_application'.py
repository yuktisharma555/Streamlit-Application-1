# -*- coding: utf-8 -*-
"""Streamlit Application'.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RNKOcpbql7OaqNuUru3Ggy7Q68P1OYeD
"""

from google.colab import files
uploaded = files.upload()   # upload your label_encoder_scikit.pkl

from google.colab import files
uploaded = files.upload()

# Make sure pyngrok and streamlit installed
!pip install --quiet pyngrok streamlit

from pyngrok import ngrok, conf
import time, os

# If you used Option A to set token, conf already has it.
# If you used Option B, set it here:
# conf.get_default().auth_token = os.environ["NGROK_AUTH_TOKEN"]

# Kill any previous tunnels just in case
ngrok.kill()

# Open a public HTTP tunnel on port 8501 (Streamlit default)
public_tunnel = ngrok.connect(addr=8501, proto="http")
print("Public URL (open this in a new browser tab):", public_tunnel.public_url)

# Run Streamlit in background (app.py must exist in current directory)
# Use nohup & so it keeps running while the cell completes
cmd = "nohup streamlit run app.py --server.port 8501 --server.address 0.0.0.0 > streamlit.log 2>&1 &"
os.system(cmd)
time.sleep(2)
print("Streamlit started in background. If the page doesn't load, check streamlit.log for errors.")

!pip install streamlit
!npm install -g cloudflared

!pip install --quiet scipy

!nohup streamlit run app.py --server.port 8501 --server.address 0.0.0.0 &

!cloudflared tunnel --url http://localhost:8501 --no-autoupdate

# Run this cell (Colab)
!pip install --quiet streamlit tensorflow pillow scikit-learn seaborn matplotlib scipy
# Install cloudflared (download .deb and install)
!wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
!apt install -y ./cloudflared-linux-amd64.deb

# Kill any old streamlit processes first (safe)
!pkill -f streamlit || true

# Start Streamlit in background with larger upload size (512 MB)
!nohup streamlit run app.py --server.port 8501 --server.address 0.0.0.0 --server.maxUploadSize 512 > streamlit.log 2>&1 &

# Let it boot and show the logs
import time, os
time.sleep(2)
print("Streamlit logs (last 200 lines):")
!tail -n 200 streamlit.log

import streamlit as st
import numpy as np
import tensorflow as tf
from PIL import Image, ImageOps
import pickle
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

st.set_page_config(page_title="ScannerID", layout="centered")
st.title("ðŸ“  ScannerID â€” Scanner Identification System")

IMG_SIZE = (256, 256)

@st.cache_resource
def load_models():
    cnn = tf.keras.models.load_model("cnn_final_model.keras")
    with open("xgb_model.pkl", "rb") as f:
        xgb = pickle.load(f)
    with open("label_encoder_scikit.pkl", "rb") as f:
        le = pickle.load(f)
    return cnn, xgb, le

cnn_model, xgb_model, label_encoder = load_models()
classes = list(label_encoder.classes_)

def preprocess_for_cnn(img):
    img = ImageOps.grayscale(img)
    img = img.resize(IMG_SIZE)
    arr = np.array(img).astype("float32") / 255.0
    return arr.reshape(1, IMG_SIZE[0], IMG_SIZE[1], 1)

def compute_features(img):
    img = ImageOps.grayscale(img)
    img = img.resize(IMG_SIZE)
    arr = np.array(img).astype("float32").flatten() / 255.0
    mean, std = np.mean(arr), np.std(arr)

    feat = np.array([
        mean, std,
        np.median(arr), np.min(arr), np.max(arr),
        0.0, 0.0, 0.0   # safe fallback for skew/kurtosis/entropy
    ], dtype="float32")

    return feat.reshape(1, -1)

st.sidebar.header("Prediction Mode")
mode = st.sidebar.selectbox("Choose:", ["CNN", "XGBoost", "Ensemble"])

uploaded = st.file_uploader("Upload image", type=["png", "jpg", "jpeg", "tif", "tiff"])

# Store true/pred labels
if "true_labels" not in st.session_state:
    st.session_state.true_labels = []
if "pred_labels" not in st.session_state:
    st.session_state.pred_labels = []

if uploaded:
    img = Image.open(uploaded)
    st.image(img, caption="Uploaded Image", use_column_width=True)

    cnn_in = preprocess_for_cnn(img)
    xgb_in = compute_features(img)

    # CNN prediction
    probs = cnn_model.predict(cnn_in)[0]
    cnn_label = classes[np.argmax(probs)]
    cnn_conf = float(np.max(probs))

    # XGB prediction
    xgb_raw = xgb_model.predict(xgb_in)[0]
    try:
        xgb_label = label_encoder.inverse_transform([int(xgb_raw)])[0]
    except:
        xgb_label = str(xgb_raw)

    # Final output
    if mode == "CNN":
        final_label = cnn_label
        st.success(f"CNN â†’ {cnn_label} ({cnn_conf:.2f})")

    elif mode == "XGBoost":
        final_label = xgb_label
        st.success(f"XGBoost â†’ {xgb_label}")

    else:  # ensemble
        if cnn_label == xgb_label or cnn_conf >= 0.6:
            final_label = cnn_label
        else:
            final_label = xgb_label

        st.success(f"Final Prediction â†’ {final_label}")

    # Logging for confusion matrix
    true_label = st.selectbox("Select TRUE label:", classes)
    if st.button("Add to Confusion Matrix"):
        st.session_state.true_labels.append(true_label)
        st.session_state.pred_labels.append(final_label)
        st.success("Sample added!")

    st.markdown("---")

    # Show confusion matrix
    if len(st.session_state.true_labels) >= 2:
        cm = confusion_matrix(
            st.session_state.true_labels,
            st.session_state.pred_labels,
            labels=classes
        )

        fig, ax = plt.subplots(figsize=(10, 8))
        disp = ConfusionMatrixDisplay(cm, display_labels=classes)
        disp.plot(ax=ax, xticks_rotation=45, cmap="Blues")
        st.pyplot(fig)